<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Top‑Down Soccer AI — v5.4 (11v11, mixed control)</title>
<style>
  :root{
    --bg:#0f1220; --panel:#171a2b; --ink:#e8ecff; --muted:#9aa3c7; --accent:#4cc9f0;
    --field:#1e7f3e; --line:#e8ecff; --blue:#3da5ff; --scarlet:#ff4d4d; --keeper:#ffd166;
    --stam:#22c55e; --tech:#facc15; --barbg:#0b1025; --red:#ff6b6b;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:600 14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial}
  .wrap{display:grid;grid-template-columns:340px 1fr;gap:16px;height:100%;padding:16px}
  .panel{background:var(--panel);border:1px solid #2a2e44;border-radius:16px;display:flex;flex-direction:column;min-height:0}
  .panel h1{font-size:16px;margin:12px 16px 4px}
  .panel .sub{color:var(--muted);font-weight:500;margin:0 16px 10px}
  fieldset{border:1px solid #2a2e44;border-radius:12px;margin:8px 12px;padding:10px}
  legend{color:var(--muted);padding:0 6px}
  label{display:block;margin:7px 0 3px;color:var(--muted);font-weight:500}
  select,button,input[type=range]{width:100%}
  select,button{appearance:none;border:1px solid #2a2e44;background:#121528;color:var(--ink);border-radius:10px;padding:10px;font-weight:700}
  button.primary{background:linear-gradient(180deg,#2a8cff,#0f5dff);border-color:#1b56d1}
  button.ghost{background:#121528}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .meter{display:flex;align-items:center;gap:8px}
  .meter output{min-width:3ch;text-align:right;color:var(--accent)}
  .scores{display:flex;align-items:center;justify-content:space-between;padding:10px 16px;border-top:1px dashed #2a2e44;margin-top:auto}
  .scores .side{display:flex;align-items:center;gap:8px}
  .dot{width:14px;height:14px;border-radius:50%}
  .dot.blue{background:var(--blue)}
  .dot.red{background:var(--scarlet)}
  canvas{display:block;background:radial-gradient(1200px 80% at 50% 0%,#0b6b31 0,#125b2b 60%, #0e4e26 100%)}
  .stage{position:relative;border:1px solid #2a2e44;border-radius:16px;overflow:hidden}
  .overlay{position:absolute;inset:8px auto auto 8px;background:#000a;padding:6px 10px;border-radius:10px;color:#fff;backdrop-filter:blur(2px)}
  .overlay .time{font-weight:800;font-size:18px}
  .overlay .hint{color:var(--muted);font-weight:500}
  .bigmsg{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#fff;font-size:44px;font-weight:900;text-shadow:0 2px 10px #000c;pointer-events:none;opacity:0}
  .bigmsg.goal{animation:pop 1.1s ease both}
  @keyframes pop{0%{transform:scale(.6);opacity:0}30%{transform:scale(1.15);opacity:1}60%{transform:scale(1)}100%{opacity:0}}
  .flash{position:absolute;inset:0;background:radial-gradient(200% 120% at 50% 50%,#fff8 0,#fff0 50%,#0000 100%);opacity:0;pointer-events:none}
  .flash.on{animation:flashA .6s ease}
  @keyframes flashA{0%{opacity:.9}100%{opacity:0}}
  .help{position:absolute;right:8px;top:8px;background:#000a;color:#fff;padding:6px 10px;border-radius:10px;backdrop-filter:blur(2px);font-weight:600}
  .charge{position:absolute;right:8px;bottom:8px;background:#000a;color:#fff;padding:6px 10px;border-radius:10px;backdrop-filter:blur(2px);font-weight:700}
</style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <h1>⚽ Top‑Down Soccer (11v11, Mixed Control)</h1>
      <p class="sub">Left‑click: pass (on release) inside the field • Right‑click: hold & release to SHOOT (power = hold time).</p>

      <fieldset>
        <legend>Match Control</legend>
        <div class="row">
          <button id="btnStart" class="primary">Start</button>
          <button id="btnPause" class="ghost">Pause</button>
        </div>
        <div class="row" style="margin-top:8px">
          <button id="btnReset" class="ghost">Reset Match</button>
          <button id="btnKickoff" class="ghost">Kickoff</button>
        </div>
        <label for="speed">Game Speed</label>
        <div class="meter">
          <input id="speed" type="range" min="0.5" max="2.0" step="0.1" value="1.0" />
          <output id="speedOut">1.0×</output>
        </div>
        <label for="duration">Match Length (min)</label>
        <div class="meter">
          <input id="duration" type="range" min="2" max="15" step="1" value="5" />
          <output id="durationOut">5:00</output>
        </div>
      </fieldset>

      <fieldset>
        <legend>Manager / Human‑Controlled Team</legend>
        <label for="managerTeam">Team</label>
        <select id="managerTeam">
          <option value="0">Blue (Left)</option>
          <option value="1">Red (Right)</option>
        </select>
      </fieldset>

      <fieldset>
        <legend>Formation & Style</legend>
        <label for="formation">Formation (11 incl. GK)</label>
        <select id="formation">
          <option value="4-4-2" selected>4‑4‑2</option>
          <option value="4-3-3">4‑3‑3</option>
          <option value="3-5-2">3‑5-2</option>
        </select>
        <label for="mentality">Mentality</label>
        <select id="mentality">
          <option value="defend">Defend</option>
          <option value="balanced" selected>Balanced</option>
          <option value="attack">Attack</option>
        </select>
        <label for="press">Press Intensity</label>
        <div class="meter">
          <input id="press" type="range" min="0" max="100" value="70" />
          <output id="pressOut">70</output>
        </div>
        <label for="width">Team Width</label>
        <div class="meter">
          <input id="width" type="range" min="70" max="130" value="100" />
          <output id="widthOut">100%</output>
        </div>
        <label for="passIntensity">Pass Intensity (AI)</label>
        <div class="meter">
          <input id="passIntensity" type="range" min="0" max="100" value="85" />
          <output id="passIntOut">85</output>
        </div>
      </fieldset>

      <fieldset>
        <legend>View</legend>
        <label for="shows">Toggles</label>
        <div class="row">
          <label style="display:flex;gap:8px;align-items:center"><input id="showZones" type="checkbox"> Show Zones</label>
          <label style="display:flex;gap:8px;align-items:center"><input id="showVectors" type="checkbox"> Show Vectors</label>
        </div>
      </fieldset>

      <div class="scores">
        <div class="side"><span class="dot blue"></span> <span>Blue</span> <b id="scoreL">0</b></div>
        <div class="side"><b id="scoreR">0</b> <span>Red</span> <span class="dot red"></span></div>
      </div>
    </div>

    <div class="stage">
      <canvas id="pitch" width="1280" height="800"></canvas>
      <div class="overlay">
        <div class="time" id="clock">05:00</div>
        <div class="hint">Human team: <b id="mgrName">Blue</b> — <span id="mgrForm">4‑4‑2</span> • <span id="mgrStyle">Balanced</span> • AI Pass <b id="mgrPass">85</b></div>
      </div>
      <div id="bigmsg" class="bigmsg"></div>
      <div id="flash" class="flash"></div>
      <div id="help" class="help">Left‑click to pass • Right‑click hold→release to shoot • G=get ball • P=test pass • S=test shot • Ball owner: <span id="ballOwner">None</span></div>
      <div id="chargeUI" class="charge" style="display:none">Shot power: <span id="chargePct">0</span>%</div>
  <div id="debugPanel" style="position:absolute;top:8px;right:8px;background:#000a;color:#e8ecff;font:11px monospace;padding:6px 8px;border-radius:6px;line-height:1.25;max-width:220px;pointer-events:none"></div>
    </div>
  </div>

<script>
(()=>{
  // ---------- Math utils ----------
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const dist2=(ax,ay,bx,by)=>{const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy};
  const rnd=(a,b)=>a+Math.random()*(b-a);
  const segPointDist=(x1,y1,x2,y2,px,py)=>{ const vx=x2-x1,vy=y2-y1, wx=px-x1,wy=py-y1; const c1=wx*vx+wy*vy; if(c1<=0) return Math.hypot(px-x1,py-y1); const c2=vx*vx+vy*vy; if(c2<=c1) return Math.hypot(px-x2,py-y2); const t=c1/c2; const projx=x1+t*vx, projy=y1+t*vy; return Math.hypot(px-projx,py-projy); };

  // ---------- Field & canvas ----------
  const canvas=document.getElementById('pitch');
  const ctx=canvas.getContext('2d');
  let W=canvas.width,H=canvas.height,scale=1; 
  const FIELD={w:120,h:80};
  const aspect=FIELD.w/FIELD.h;
  
  function resize(){
    const rect=canvas.parentElement.getBoundingClientRect();
    let tw=rect.width-32, th=tw/aspect; // Account for padding
    if(th>rect.height-32){
      th=rect.height-32; 
      tw=th*aspect;
    } 
    canvas.width=tw|0; 
    canvas.height=th|0; 
    
    // Fix: Set canvas CSS size to match actual canvas dimensions
    canvas.style.width = canvas.width + 'px';
    canvas.style.height = canvas.height + 'px';
    
    W=canvas.width; 
    H=canvas.height; 
    scale=W/FIELD.w;
    console.log('Canvas resized:', {W, H, scale, fieldW: FIELD.w, fieldH: FIELD.h});
  }
  addEventListener('resize',resize,{passive:true}); resize();

  // ---------- Game constants ----------
  const LEFT=0, RIGHT=1;
  const COLORS={ [LEFT]:{kit:'#3da5ff',keeper:'#ffd166'}, [RIGHT]:{kit:'#ff4d4d',keeper:'#ffd166'} };
  const GOAL={width:7.32,height:2.5}; const BOX={w:18.3,h:40.3}; const SIX={w:6,h:24};

  const cfg={ simulate:true, speed:1, halfLen:5, timeLeft:5*60*1000, kickoff:LEFT, showZones:false, showVectors:false };
  const score={ [LEFT]:0,[RIGHT]:0 };
  let gTime=0;

  // Persistent ability per side
  const rosterAbility={ [LEFT]:null,[RIGHT]:null };
  function ensureRoster(side){ if(!rosterAbility[side]) rosterAbility[side]=Array.from({length:11},()=>rnd(60,78)); }

  // ---------- Mouse control (human team) ----------
  let humanSide = LEFT; // synced to managerTeam
  let leftDown=false, rightDown=false; let leftDownTime=0, rightDownTime=0; let mouse={x:0,y:0};
  const chargeUI=document.getElementById('chargeUI'); const chargePct=document.getElementById('chargePct');
  const SHOT_MIN=70, SHOT_MAX=95, SHOT_CHARGE_S=2.5; // Tuned for dt-based physics

  function clientToField(e){ 
    const rect=canvas.getBoundingClientRect(); 
    const x = (e.clientX - rect.left) / scale; 
    const y = (e.clientY - rect.top) / scale; 
    const inside = (x >= 1 && x <= FIELD.w-1 && y >= 1 && y <= FIELD.h-1);
    console.log('📍 clientToField:', {
      mouse: [e.clientX, e.clientY],
      canvas: [rect.left.toFixed(1), rect.top.toFixed(1)],
      relative: [(e.clientX - rect.left).toFixed(1), (e.clientY - rect.top).toFixed(1)],
      field: [x.toFixed(1), y.toFixed(1)],
      scale: scale.toFixed(2),
      inside
    });
    return {x, y, inside}; 
  }

  canvas.addEventListener('contextmenu', e=>{ e.preventDefault(); });
  canvas.addEventListener('mousemove', (e)=>{ const p=clientToField(e); mouse.x=p.x; mouse.y=p.y; });
  canvas.addEventListener('mousedown', (e)=>{
    e.preventDefault();
  const rawEvtInfo={btn:e.button, client:[e.clientX,e.clientY]};
    
    // Auto-give ball to human team if they don't have it and user clicks
    if(!ball.owner || ball.owner.team !== humanSide) {
      console.log('🔄 Auto-giving ball to human team on click');
      const humanTeam = teams[humanSide];
      const closestPlayer = humanTeam.playersNonGK.reduce((closest, player) => {
        const d1 = dist2(player.x, player.y, ball.x, ball.y);
        const d2 = dist2(closest.x, closest.y, ball.x, ball.y);
        return d1 < d2 ? player : closest;
      });
      ball.owner = closestPlayer;
      closestPlayer.hasBall = true;
      ball.vx = ball.vy = 0;
    }
    
  const p=clientToField(e);
  console.log('🖱️ Mouse down:', { ...rawEvtInfo, field:[p.x.toFixed(2),p.y.toFixed(2)], inside:p.inside, ballOwner: ball.owner? (ball.owner.team===LEFT?'LEFT':'RIGHT'):null, humanSide, hasOwner: !!ball.owner});
    if(e.button===0){ leftDown=true; leftDownTime=performance.now(); }
    if(e.button===2){ rightDown=true; rightDownTime=performance.now(); if(ball.owner && ball.owner.team===humanSide){ chargeUI.style.display='block'; updateCharge(); } }
  });
  
  // Fix: Attach mouseup to canvas instead of window, and add fallback for window
  canvas.addEventListener('mouseup', (e)=>{
    e.preventDefault();
    const p=clientToField(e);
  console.log('🖱️ Mouse up:', {button:e.button, field:[p.x.toFixed(2),p.y.toFixed(2)], inside:p.inside, ballOwner:ball.owner? (ball.owner.team===LEFT?'LEFT':'RIGHT'):null, humanSide, leftDown,rightDown, hasCorrectTeam: ball.owner?.team===humanSide});
    
    if(e.button===0){ // PASS on left release (only if release inside field)
      if(leftDown) {
        leftDown=false;
        if(ball.owner && ball.owner.team===humanSide){ 
          if(p.inside) {
            const passInt=passSettings[humanSide];
            console.log('✅ PASS INIT', {from:{x:ball.owner.x.toFixed(2),y:ball.owner.y.toFixed(2)}, to:[p.x.toFixed(2),p.y.toFixed(2)], passInt});
            window.__lastPassDebug={time:performance.now(), from:{x:ball.owner.x,y:ball.owner.y}, to:{x:p.x,y:p.y}, passInt};
            kickPassTowardPoint(ball.owner, p.x, p.y, passInt); 
          } else {
            console.log('❌ Pass failed - click outside field bounds');
          }
        } else {
          console.log('❌ Pass failed - no ball or wrong team');
        }
      }
    } else if(e.button===2){ // SHOOT on right release
      if(rightDown){ 
        rightDown=false; chargeUI.style.display='none'; 
        if(ball.owner && ball.owner.team===humanSide){ 
          const hold=(performance.now()-rightDownTime)/1000; 
          const t=clamp(hold/SHOT_CHARGE_S,0,1); 
          const power=SHOT_MIN + t*(SHOT_MAX-SHOT_MIN); 
          console.log('✅ SHOT INIT', {hold:hold.toFixed(2), t:t.toFixed(2), power:power.toFixed(2)});
          shootToGoal(ball.owner, power); 
        } else {
          console.log('❌ Shot failed - no ball or wrong team');
        }
      }
    }
  });
  
  // Fallback for mouseup outside canvas
  addEventListener('mouseup', (e)=>{
    if(e.button===0 && leftDown){ 
      leftDown=false; 
    } else if(e.button===2 && rightDown){ 
      rightDown=false; chargeUI.style.display='none'; 
      if(ball.owner && ball.owner.team===humanSide){ 
        const hold=(performance.now()-rightDownTime)/1000; 
        const t=clamp(hold/SHOT_CHARGE_S,0,1); 
        const power=SHOT_MIN + t*(SHOT_MAX-SHOT_MIN); 
        shootToGoal(ball.owner, power); 
      } 
    }
  });
  
  // DEBUG: Add keyboard control to give human team the ball for testing
  addEventListener('keydown', (e) => {
    if(e.key === 'g' || e.key === 'G') {
      console.log('🔄 Giving ball to human team for testing');
      const humanTeam = teams[humanSide];
      const closestPlayer = humanTeam.playersNonGK.reduce((closest, player) => {
        const d1 = dist2(player.x, player.y, ball.x, ball.y);
        const d2 = dist2(closest.x, closest.y, ball.x, ball.y);
        return d1 < d2 ? player : closest;
      });
      ball.owner = closestPlayer;
      closestPlayer.hasBall = true;
      ball.vx = ball.vy = 0;
      console.log('✅ Ball given to:', `${closestPlayer.team === LEFT ? 'Blue' : 'Red'} ${closestPlayer.role} at (${closestPlayer.x.toFixed(1)}, ${closestPlayer.y.toFixed(1)})`);
    }
    
    // Test pass with keyboard
    if(e.key === 'p' || e.key === 'P') {
      if(ball.owner && ball.owner.team === humanSide) {
        console.log('🎯 Testing pass with keyboard');
        const targetX = ball.owner.x + (ball.owner.team === LEFT ? 15 : -15);
        const targetY = ball.owner.y + rnd(-10, 10);
        kickPassTowardPoint(ball.owner, clamp(targetX, 5, FIELD.w-5), clamp(targetY, 5, FIELD.h-5), passSettings[humanSide]);
      } else {
        console.log('❌ No ball to pass - press G first');
      }
    }
    
    // Test shot with keyboard  
    if(e.key === 's' || e.key === 'S') {
      if(ball.owner && ball.owner.team === humanSide) {
        console.log('🥅 Testing shot with keyboard');
        shootToGoal(ball.owner, 35);
      } else {
        console.log('❌ No ball to shoot - press G first');
      }
    }
  });

  function updateCharge(){ if(!rightDown) return; const hold=(performance.now()-rightDownTime)/1000; const pct=clamp(hold/SHOT_CHARGE_S,0,1)*100; chargePct.textContent=pct.toFixed(0); }
  setInterval(()=>updateCharge(), 60);

  function kickPassTowardPoint(passer, tx, ty, passInt){ // human pass
    console.log('⚽ kickPassTowardPoint called:', {
      passer: `${passer.team === LEFT ? 'Blue' : 'Red'} ${passer.role}`, 
      target: [tx.toFixed(1), ty.toFixed(1)], 
      passInt,
      ballBefore: [ball.x.toFixed(1), ball.y.toFixed(1)]
    });
  const power = 40 + (passInt-60)*0.4; // Typical 60-90 -> 40-52 u/s
    const dirx = tx - passer.x, diry = ty - passer.y; 
    const d=Math.hypot(dirx,diry)||1; 
    const ex=passer.x + dirx/d * (d + 0.01); 
    const ey=passer.y + diry/d * (d + 0.01);
    let err = (100-passer.ability)/100 * 1.2; // Improved: slightly more accurate for human control
    const finalX = ex + rnd(-err,err);
    const finalY = ey + rnd(-err,err);
    console.log('⚽ Ball kick params:', {power: power.toFixed(1), target: [finalX.toFixed(1), finalY.toFixed(1)]});
    ball.kickAt(finalX, finalY, power);
    console.log('⚽ Ball after kick:', {pos: [ball.x.toFixed(1), ball.y.toFixed(1)], vel: [ball.vx.toFixed(1), ball.vy.toFixed(1)], owner: ball.owner});
  }
  function shootToGoal(passer, power){ 
    console.log('shootToGoal called:', {passer: passer.team, power});
    const side=passer.team; const inacc=(100-passer.ability)/100*2.0; const gy=FIELD.h/2 + rnd(-GOAL.height/2+0.3,GOAL.height/2-0.3) + rnd(-inacc,inacc); const tx=(side===LEFT)? FIELD.w+1 : -1; 
    console.log('Shooting towards:', [tx, gy]);
    ball.kickAt(tx, gy, power); 
  }

  // ---------- Entities ----------
  class Ball{ 
    constructor(){this.x=FIELD.w/2;this.y=FIELD.h/2;this.vx=0;this.vy=0;this.owner=null;this.lastKickBy=null;this.lastKickAt=-999;} 
    update(dt){ 
      if(this.owner){const p=this.owner,f=p.facing(); this.x=p.x+f.x*0.8; this.y=p.y+f.y*0.8; this.vx=this.vy=0; return;} 
      this.x+=this.vx*dt; this.y+=this.vy*dt; 
      this.vx*=Math.pow(0.995,dt*60); this.vy*=Math.pow(0.995,dt*60); 
      if(this.y<1){this.y=1; this.vy*=-0.6} 
      if(this.y>FIELD.h-1){this.y=FIELD.h-1; this.vy*=-0.6} 
      if(this.x<0){this.x=0; this.vx*=-0.6} 
      if(this.x>FIELD.w){this.x=FIELD.w; this.vx*=-0.6} 
    } 
    kickAt(tx,ty,power){ 
      const prev=this.owner; if(prev) prev.hasBall=false; this.owner=null; 
      const dx=tx-this.x,dy=ty-this.y; const d=Math.hypot(dx,dy)||1; const nx=dx/d, ny=dy/d; 
      // offset so kicker doesn't instantly retake
      this.x+=nx*0.9; this.y+=ny*0.9; 
      this.vx=nx*power; this.vy=ny*power; 
      this.lastKickBy=prev; this.lastKickAt=gTime; 
      const max=120; const sp=Math.hypot(this.vx,this.vy); if(sp>max){ this.vx=this.vx/sp*max; this.vy=this.vy/sp*max; }
    } 
  }

  class Player{
    constructor(team,role,home,ability=65){ this.team=team; this.role=role; this.homeBase={...home}; this.home={...home}; this.x=home.x; this.y=home.y; this.vx=0; this.vy=0; this.baseSpeed=(role==='GK')?11:16; this.accelBase=65; this.radius=0.7; this.target={x:this.x,y:this.y}; this.hasBall=false; this.possessionTime=0; this.lastTouch=-999; this.stamina=100; this.ability=ability; }
    effectiveSpeed(){return this.baseSpeed*(0.6+0.4*(this.stamina/100));}
    effectiveAccel(){return this.accelBase*(0.6+0.4*(this.stamina/100));}
    facing(){const dir=(this.team===LEFT)?1:-1; return {x:dir,y:0};}
    think(dt,world){ const {ball,teams,passSettings}=world; const us=teams[this.team], them=teams[1-this.team]; const passInt=passSettings[this.team];
      this.possessionTime = this.hasBall ? this.possessionTime+dt : 0;
      // GK logic
      if(this.role==='GK'){
        const gx=(this.team===LEFT)?1.5:FIELD.w-1.5; const gy=clamp(ball.y, FIELD.h/2-BOX.h/2+2, FIELD.h/2+BOX.h/2-2);
        const within=dist2(ball.x,ball.y,gx,gy)<BOX.w*BOX.w;
        this.target= within? {x:clamp(ball.x,3.5,FIELD.w-3.5),y:gy} : {x:gx,y:FIELD.h/2};
        if(ball.owner===this){
          const mate=bestOutlet(this,us,them);
          // Human GK: pass automatically if user doesn't act for a bit (prevents stalls)
          if(this.team===humanSide){ if(this.possessionTime>1.2 && mate) passBall(this,mate,world,passInt); }
          else { if(mate) passBall(this,mate,world,passInt); }
        }
        return;
      }
      // Closest to ball among non-GK
      let closest=null,bd2=1e9; for(const p of us.playersNonGK){ if(!Number.isFinite(p.x)||!Number.isFinite(p.y)) continue; const d2=dist2(p.x,p.y,ball.x,ball.y); if(d2<bd2){bd2=d2; closest=p}} const hunter=(closest===this);

      // Possession
      if(ball.owner===this){
        const enemyGoal=(this.team===LEFT)? RIGHT:LEFT; const goalX=(enemyGoal===LEFT)?0:FIELD.w; const dGoal=Math.abs(goalX-this.x);
        const finalThird=(this.team===LEFT)? (this.x>FIELD.w*0.66):(this.x<FIELD.w*0.34);
        const shootRange=16 + (this.ability-60)*0.05;
        if(this.team===humanSide){
          // Human team: no auto-pass; dribble gently toward goal while waiting for input
          const dir=(this.team===LEFT)?1:-1; this.target={x:clamp(this.x+dir*5,0,FIELD.w), y: clamp(this.y + rnd(-2.5,2.5), 2, FIELD.h-2)}; return;
        }
        // AI team: pass‑first engine
        const mate = choosePass(this, us, them, world);
        const forcedTime = 0.5 * (finalThird? 1.2: 0.9); // quick cycling
        // Fix: Lower pass threshold to make AI pass more frequently
        const passThreshold = 0.45 - passInt*0.0035 + clamp((dGoal-18)/30,0,0.15);
        const goodPass = mate && mate._score > passThreshold;
        const mustPass = this.possessionTime>forcedTime;
        
        // Debug AI passing (reduced frequency)
        if(Math.floor(gTime) % 5 === 0 && gTime % 60 < 1) { // Log every 5 seconds
          console.log('AI player thinking:', {
            team: this.team, 
            role: this.role, 
            mate: mate ? `${mate.role} (score: ${mate._score?.toFixed(2)})` : 'none',
            goodPass, 
            mustPass
          });
        }
        
        if(dGoal<shootRange){ 
          console.log('AI shooting at goal');
          shootToGoal(this, 31); 
          return; 
        }
        if(mate && (goodPass || mustPass)){ 
          console.log('AI passing:', {from: this.role, to: mate.role, score: mate._score, goodPass, mustPass});
          passBall(this, mate, world, passInt); 
          return; 
        }
        // else small dribble
        const dir=(this.team===LEFT)?1:-1; this.target={x:clamp(this.x+dir*5,0,FIELD.w), y: clamp(this.y + rnd(-2.5,2.5), 2, FIELD.h-2)}; return;
      }
      // Off-ball
      const dHomeBall2=dist2(this.home.x,this.home.y,ball.x,ball.y); const engage = dHomeBall2<(us.params.press*us.params.press);
      if(hunter && engage){ const leash=us.params.leash; const hx=this.home.x,hy=this.home.y; const dx=ball.x-hx,dy=ball.y-hy; const d=Math.hypot(dx,dy)||1; const t=Math.min(leash/d,1.0); this.target={x:hx+dx*t,y:hy+dy*t}; return; }
      // Soft mark
      let markOpp=them.nearestInLane(this.y, us.band[this.role]); if(markOpp){ const goalX=(this.team===LEFT)?0:FIELD.w; const mx=lerp(markOpp.x,goalX,0.1); const my=lerp(markOpp.y,FIELD.h/2,0.06); this.target={x:lerp(mx,this.home.x,0.5), y: lerp(my,this.home.y,0.5)}; } else { this.target={x:this.home.x,y:this.home.y}; }
      // Leash
      const leash=us.params.leash; const hx=this.home.x,hy=this.home.y; const dx=this.target.x-hx,dy=this.target.y-hy; const dd=Math.hypot(dx,dy); if(dd>leash){ this.target.x=hx+dx*(leash/dd); this.target.y=hy+dy*(leash/dd);} }
  physics(dt,world){ const tx=this.target.x,ty=this.target.y; const dx=tx-this.x,dy=ty-this.y; const d=Math.hypot(dx,dy)||1; const ax=(dx/d)*this.effectiveAccel()*dt, ay=(dy/d)*this.effectiveAccel()*dt; this.vx+=ax; this.vy+=ay; const sp=Math.hypot(this.vx,this.vy)||1; const ms=this.effectiveSpeed(); if(sp>ms){ this.vx=this.vx/sp*ms; this.vy=this.vy/sp*ms; } const px=this.x,py=this.y; this.x+=this.vx*dt; this.y+=this.vy*dt; this.vx*=Math.pow(0.98,dt*60); this.vy*=Math.pow(0.98,dt*60); this.x=clamp(this.x,1.2,FIELD.w-1.2); this.y=clamp(this.y,1,FIELD.h-1); const moved=Math.hypot(this.x-px,this.y-py); this.stamina=clamp(this.stamina - moved*0.03, 0,100); const b=world.ball; if(!b.owner){ const r2=dist2(this.x,this.y,b.x,b.y); const cooldown=0.25; const canPickup=!(b.lastKickBy===this && (gTime-b.lastKickAt)<cooldown); if(r2<1.0 && canPickup){ b.owner=this; this.hasBall=true; this.possessionTime=0; this.lastTouch=gTime; } else this.hasBall=false; } else this.hasBall=(b.owner===this); }
    draw(ctx){ const col=(this.role==='GK')?COLORS[this.team].keeper:COLORS[this.team].kit; ctx.save(); ctx.translate(this.x*scale,this.y*scale); ctx.beginPath(); ctx.arc(0,0,this.radius*scale,0,Math.PI*2); ctx.fillStyle=col; ctx.fill(); ctx.fillStyle="#0a0a0a"; ctx.font=`${Math.max(10,0.34*scale)}px ui-sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle'; const letter=(this.role==='GK')?'G':(this.role==='DEF')?'D':(this.role==='MID')?'M':'F'; ctx.fillText(letter,0,0.2*scale); const bw=2.6*scale,bh=0.18*scale,gap=0.16*scale,offY=-1.2*scale; ctx.fillStyle='rgba(10,14,30,.75)'; ctx.fillRect(-bw/2,offY-bh,bw,bh); ctx.fillRect(-bw/2,offY-bh-gap-bh,bw,bh); ctx.fillStyle='#22c55e'; ctx.fillRect(-bw/2,offY-bh,bw*(this.stamina/100),bh); ctx.fillStyle='#facc15'; ctx.fillRect(-bw/2,offY-bh-gap-bh,bw*(this.ability/100),bh); ctx.restore(); }
  }

  function laneOpen(passer, receiver, opponents){ const x1=passer.x,y1=passer.y,x2=receiver.x,y2=receiver.y; let best=1e9; for(const o of opponents){ if(!Number.isFinite(o.x)||!Number.isFinite(o.y)) continue; const d=segPointDist(x1,y1,x2,y2,o.x,o.y); if(d<best) best=d; } return best; }
  function choosePass(passer, us, them, world){ 
    let best=null, bestScore=-1; 
    const goalX=(passer.team===LEFT)? FIELD.w:0; 
    const opp=them.playersNonGK; 
    for(const mate of us.playersNonGK){ 
      if(mate===passer) continue; 
      if(!Number.isFinite(mate.x)||!Number.isFinite(mate.y)) continue; 
      const clearance = laneOpen(passer, mate, opp); 
      const clearScore = clamp((clearance-0.6)/3.0, 0, 1.2); // Improved: lower threshold, higher max
      const prog = Math.max(0, (Math.abs(goalX - passer.x) - Math.abs(goalX - mate.x))); 
      const progScore = clamp(prog/14, 0, 1.4); // Improved: easier progression scoring
      const d = Math.hypot(mate.x-passer.x, mate.y-passer.y); 
      const distPref = 1 - Math.abs((d-12)/14); // Improved: prefer closer passes
      const mark = them.nearestDist2(mate.x,mate.y); 
      const unmark = 1.2/Math.sqrt(mark+1); // Improved: higher weight for unmarked players
      const fresh = clamp((gTime - (mate.lastTouch||-1000))/8,0,1.1); // Improved: reward fresh players more
      const ahead = (passer.team===LEFT)? (mate.x>passer.x):(mate.x<passer.x); 
      const aheadW = ahead? 1.2: 0.85; // Improved: stronger preference for forward passes
      const laneCenter = 1 - Math.abs((mate.y/FIELD.h) - 0.5); 
      const score = clearScore*1.4 + progScore*1.1 + distPref*1.0 + unmark*1.1 + fresh*0.8 + laneCenter*0.3; // Improved weights
      const finalScore = score * aheadW; 
      if(finalScore>bestScore){ bestScore=finalScore; best=mate; best._score=finalScore; } 
    } 
    return best; 
  }
  function bestOutlet(gk, us, them){ let best=null, bestScore=-1; for(const m of us.playersNonGK){ if(!Number.isFinite(m.x)||!Number.isFinite(m.y)) continue; const mark=them.nearestDist2(m.x,m.y); const unmark=1/Math.sqrt(mark+1); const ahead=(gk.team===LEFT)? (m.x>gk.x):(m.x<gk.x); const score=unmark*1.2 + (ahead?0.4:0); if(score>bestScore){bestScore=score; best=m} } return best; }
  function passBall(passer, receiver, world, passInt){ 
    const {ball}=world; 
    const power = 150 + passInt*1.0; // Fixed: Match human pass power with dt scaling
    const leadT = 0.20 + (passer.ability/100)*0.28; // Improved: better lead time calculation
    const tx = receiver.x + receiver.vx*leadT; 
    const ty = receiver.y + receiver.vy*leadT; 
    let err = (100-passer.ability)/100 * 2.0; // Improved: slightly less error
    err *= (0.85 + passInt/100*0.3); // Improved: pass intensity affects accuracy more
    ball.kickAt(tx + rnd(-err,err), ty + rnd(-err,err), power); 
  }

  class Team{ constructor(side,formation){ this.side=side; this.formationName=formation; this.params={ press:28, leash:11, bias:0, width:1.0, passIntensity:85 }; this.band={DEF:[0,0.4], MID:[0.3,0.7], FWD:[0.6,1]}; const spots=buildFormation(side,formation); ensureRoster(side); this.players=spots.map((s,i)=> new Player(side,s.role,{...s.pos}, rosterAbility[side][i] )); this.playersNonGK=this.players.filter(p=>p.role!=='GK'); }
    setFormation(name){ this.formationName=name; const spots=buildFormation(this.side,name); for(let i=0;i<this.players.length;i++){ const p=this.players[i], sp=spots[i]; p.role=sp.role; p.homeBase={...sp.pos}; p.home={...sp.pos}; } this.playersNonGK=this.players.filter(p=>p.role!=='GK'); }
    setParams({mentality,press,width,passIntensity}){ const bias=(mentality==='attack')?+6:(mentality==='defend')?-6:0; this.params.bias=bias*(this.side===LEFT?+1:-1); this.params.press=lerp(18,34,(press??70)/100); this.params.leash=11; this.params.width=clamp((width??100)/100,0.7,1.3); this.params.passIntensity=(passIntensity??85); }
    applyDynamicHomes(){ for(const p of this.players){ if(p.role==='GK'){ p.home={...p.homeBase}; p.x=(this.side===LEFT)?1.5:FIELD.w-1.5; p.y=FIELD.h/2; continue; } const cx=p.homeBase.x + this.params.bias; const offY=(p.homeBase.y-FIELD.h/2)*this.params.width; p.home.x=clamp(cx,6,FIELD.w-6); p.home.y=clamp(FIELD.h/2+offY,4,FIELD.h-4); } }
    nearestDist2(x,y){ let best=1e9; for(const p of this.playersNonGK){ if(!Number.isFinite(p.x)||!Number.isFinite(p.y)) continue; const d2=dist2(x,y,p.x,p.y); if(d2<best) best=d2; } return best; }
    nearestInLane(y,band){ let c=null,b=1e9; for(const p of this.playersNonGK){ if(!Number.isFinite(p.y)) continue; const ok=(p.y>=FIELD.h*band[0] && p.y<=FIELD.h*band[1]); if(!ok) continue; const d2=(p.y-y)*(p.y-y); if(d2<b){b=d2; c=p;} } return c; }
  }

  function mirrorX(x){return FIELD.w-x;} function rows(arr){return arr.map(v=>v*FIELD.h);} function col(xn){return xn*FIELD.w;}
  function spotsFor(name){ if(name==='4-4-2'){ const gk=[{role:'GK',pos:{x:1.5,y:FIELD.h*0.5}}]; const def=rows([0.12,0.32,0.68,0.88]).map(y=>({role:'DEF',pos:{x:col(0.22),y}})); const mid=rows([0.15,0.35,0.65,0.85]).map(y=>({role:'MID',pos:{x:col(0.50),y}})); const fwd=rows([0.40,0.60]).map(y=>({role:'FWD',pos:{x:col(0.78),y}})); return [...gk,...def,...mid,...fwd]; } if(name==='4-3-3'){ const gk=[{role:'GK',pos:{x:1.5,y:FIELD.h*0.5}}]; const def=rows([0.12,0.32,0.68,0.88]).map(y=>({role:'DEF',pos:{x:col(0.22),y}})); const mid=rows([0.25,0.50,0.75]).map(y=>({role:'MID',pos:{x:col(0.48),y}})); const fwd=rows([0.20,0.50,0.80]).map(y=>({role:'FWD',pos:{x:col(0.80),y}})); return [...gk,...def,...mid,...fwd]; } const gk=[{role:'GK',pos:{x:1.5,y:FIELD.h*0.5}}]; const def=rows([0.25,0.50,0.75]).map(y=>({role:'DEF',pos:{x:col(0.24),y}})); const mid=rows([0.12,0.30,0.50,0.70,0.88]).map(y=>({role:'MID',pos:{x:col(0.50),y}})); const fwd=rows([0.40,0.60]).map(y=>({role:'FWD',pos:{x:col(0.80),y}})); return [...gk,...def,...mid,...fwd]; }
  function buildFormation(side,name){ const base=spotsFor(name).map(s=>({role:s.role,pos:{...s.pos}})); if(side===RIGHT){ for(const s of base){ s.pos.x=mirrorX(s.pos.x); } } return base; }

  // ---------- World ----------
  const ball=new Ball();
  let teams=[new Team(LEFT,'4-4-2'), new Team(RIGHT,'4-4-2')];
  const passSettings={ [LEFT]:85, [RIGHT]:85 };

  let managerSide=LEFT; const $=id=>document.getElementById(id);
  function applyManager(){ const side=managerSide, t=teams[side]; humanSide=side; const form=$('formation').value; const mentality=$('mentality').value; const press=+$('press').value; const width=+$('width').value; const passIntensity=+$('passIntensity').value; t.setFormation(form); t.setParams({mentality,press,width,passIntensity}); t.applyDynamicHomes(); passSettings[side]=passIntensity; $('mgrName').textContent=(side===LEFT?'Blue':'Red'); $('mgrForm').textContent=form; $('mgrStyle').textContent=mentality[0].toUpperCase()+mentality.slice(1); $('mgrPass').textContent=passIntensity; $('help').textContent = `Left‑click pass (release inside field). Right‑click hold → release to shoot.`; }
  function applyOpponent(side){ const t=teams[side]; t.setParams({mentality:'balanced',press:75,width:100,passIntensity:88}); t.applyDynamicHomes(); passSettings[side]=88; }
  applyManager(); applyOpponent(RIGHT);

  // ---------- UI ----------
  $('managerTeam').addEventListener('change',e=>{managerSide=+e.target.value; applyManager(); applyOpponent(1-managerSide)});
  $('formation').addEventListener('change',applyManager);
  $('mentality').addEventListener('change',applyManager);
  $('press').addEventListener('input',e=>{$('pressOut').textContent=e.target.value; applyManager()});
  $('width').addEventListener('input',e=>{$('widthOut').textContent=e.target.value+'%'; applyManager()});
  $('passIntensity').addEventListener('input',e=>{$('passIntOut').textContent=e.target.value; applyManager()});
  $('speed').addEventListener('input',e=>{cfg.speed=+e.target.value;$('speedOut').textContent=e.target.value+'×'});
  $('duration').addEventListener('input',e=>{cfg.halfLen=+e.target.value;$('durationOut').textContent=e.target.value+':00'; resetMatch(true)});
  $('showZones').addEventListener('change',e=>{cfg.showZones=e.target.checked});
  $('showVectors').addEventListener('change',e=>{cfg.showVectors=e.target.checked});
  $('btnStart').addEventListener('click',()=>{cfg.simulate=true; hideMsg()});
  $('btnPause').addEventListener('click',()=>{cfg.simulate=false; showMsg('Paused')});
  $('btnReset').addEventListener('click',()=>resetMatch());
  $('btnKickoff').addEventListener('click',()=>kickoff(cfg.kickoff));

  function resetMatch(keepScores=false){ cfg.timeLeft=cfg.halfLen*60*1000; if(!keepScores){score[LEFT]=0;score[RIGHT]=0;updateScore();} ensureRoster(LEFT); ensureRoster(RIGHT); teams=[new Team(LEFT,$('formation').value), new Team(RIGHT,'4-4-2')]; applyManager(); applyOpponent(1-managerSide); for(const t of teams){ for(const p of t.players){ p.stamina=100; } } ball.x=FIELD.w/2; ball.y=FIELD.h/2; ball.vx=ball.vy=0; ball.owner=null; cfg.kickoff=(Math.random()<0.5?LEFT:RIGHT); kickoff(cfg.kickoff); hideMsg(); gTime=0; }
  function kickoff(side){ for(const t of teams){ for(const p of t.players){ p.x=p.home.x; p.y=p.home.y; if(p.role==='GK'){ p.x=(t.side===LEFT)?1.5:FIELD.w-1.5; p.y=FIELD.h/2; } p.vx=p.vy=0; p.hasBall=false; } } ball.x=FIELD.w/2; ball.y=FIELD.h/2; ball.vx=ball.vy=0; ball.owner=null; const t=teams[side]; let best=null,bd2=1e9; for(const p of t.players){ if(p.role==='FWD'){ const d2=dist2(p.home.x,p.home.y,FIELD.w/2,FIELD.h/2); if(d2<bd2){bd2=d2;best=p} } } if(!best){ best=t.players.find(p=>p.role!=='GK')||t.players[1]; } best.x=FIELD.w/2+(side===LEFT?-1:1)*2; best.y=FIELD.h/2; ball.owner=best; best.hasBall=true; best.lastTouch=gTime; if(side!==humanSide){ const mids=t.players.filter(p=>p.role==='MID'); if(mids.length){ const r=mids.reduce((a,b)=> (dist2(a.x,a.y,best.x,best.y)<dist2(b.x,b.y,best.x,best.y)?a:b)); setTimeout(()=>{ if(ball.owner===best){ passBall(best,r,{ball},passSettings[side]); } }, 150); } }
  }

  function updateScore(){ $('scoreL').textContent=score[LEFT]; $('scoreR').textContent=score[RIGHT]; }
  function goalFor(side){ score[side]++; updateScore(); flashGoal((side===LEFT?'BLUE ':'RED ')+'GOAL!'); cfg.kickoff=1-side; setTimeout(()=>{ hideMsg(); kickoff(cfg.kickoff); },1100); }
  function flashGoal(text){ const el=$('bigmsg'); el.textContent=text; el.classList.remove('goal'); void el.offsetWidth; el.classList.add('goal'); const fl=$('flash'); fl.classList.remove('on'); void fl.offsetWidth; fl.classList.add('on'); }
  function showMsg(t){ const el=$('bigmsg'); el.textContent=t; el.classList.remove('goal'); el.style.opacity=1; } function hideMsg(){ $('bigmsg').style.opacity=0; }
  function endMatch(){ showMsg('FULL TIME'); for(const side of [LEFT,RIGHT]){ ensureRoster(side); for(let i=0;i<rosterAbility[side].length;i++){ rosterAbility[side][i]=clamp(rosterAbility[side][i]+rnd(0.5,1.5),40,99); } } }

  // --- Goal check extracted so ball scores even while being dribbled across the line ---
  function goalSideIfAny(b){ const inPost=(b.y>FIELD.h/2-GOAL.height/2 && b.y<FIELD.h/2+GOAL.height/2);
    if(!inPost) return null; if(b.x<=0.4) return RIGHT; if(b.x>=FIELD.w-0.4) return LEFT; return null; }

  // ---------- Loop ----------
  let last=performance.now();
  function loop(now){ const raw=(now-last)/1000; last=now; const dt=raw*cfg.speed; if(cfg.simulate && cfg.timeLeft>0){ step(dt); cfg.timeLeft-=dt*1000; gTime+=dt; if(cfg.timeLeft<=0){ cfg.timeLeft=0; cfg.simulate=false; endMatch(); } } draw(); requestAnimationFrame(loop); }
  requestAnimationFrame(loop);

  function step(dt){
    for(const t of teams){ for(const p of t.players){ p.think(dt,{ball,teams,passSettings}); } }
    for(const t of teams){ for(const p of t.players){ p.physics(dt,{ball,teams}); } }
    ball.update(dt);
    // soft touch deflections
    if(!ball.owner){ 
      const pickupCooldown=0.25; // seconds after you kick before you can re-collect instantly
      for(const t of teams){ for(const p of t.players){ 
        const r2=dist2(p.x,p.y,ball.x,ball.y); 
        if(r2<0.7*0.7){ 
          // only deflect if not just the kicker immediately re-contacting
          if(!(ball.lastKickBy===p && (gTime-ball.lastKickAt)<pickupCooldown)){ 
            const dx=ball.x-p.x,dy=ball.y-p.y,d=Math.hypot(dx,dy)||1; 
            ball.vx=(dx/d)*22; ball.vy=(dy/d)*22; 
          }
        } 
      } } 
    }
    // goal detection even if dribbling the ball in
    const g=goalSideIfAny(ball); if(g!==null){ goalFor(g); }
  }

  // ---------- Render ----------
  function draw(){ 
    ctx.clearRect(0,0,canvas.width,canvas.height); 
    drawField(); 
    if(cfg.showZones){ for(const t of teams){ for(const p of t.players){ ctx.beginPath(); ctx.arc(p.home.x*scale,p.home.y*scale,t.params.leash*scale,0,Math.PI*2); ctx.strokeStyle=(t.side===LEFT?'#5bb0ff55':'#ff8b8b55'); ctx.stroke(); } } } 
    // ball
    ctx.save(); ctx.translate(ball.x*scale,ball.y*scale); ctx.beginPath(); ctx.arc(0,0,0.35*scale,0,Math.PI*2); ctx.fillStyle='#fff'; ctx.fill(); ctx.restore(); 
    // ball velocity vector debug
    if(Math.hypot(ball.vx,ball.vy)>0.01){
      ctx.strokeStyle='rgba(255,255,255,0.5)'; ctx.lineWidth=2; 
      ctx.beginPath(); ctx.moveTo(ball.x*scale,ball.y*scale); ctx.lineTo((ball.x+ball.vx*0.4)*scale,(ball.y+ball.vy*0.4)*scale); ctx.stroke();
    }
    // last pass intent
    if(window.__lastPassDebug && performance.now()-window.__lastPassDebug.time<4000){
      const d=window.__lastPassDebug;
      ctx.strokeStyle='#0ff'; ctx.setLineDash([4,4]);
      ctx.beginPath(); ctx.moveTo(d.from.x*scale,d.from.y*scale); ctx.lineTo(d.to.x*scale,d.to.y*scale); ctx.stroke(); ctx.setLineDash([]);
      ctx.fillStyle='#0ff'; ctx.font=`${Math.max(10,0.32*scale)}px ui-sans-serif`;
      ctx.fillText('PASS', d.to.x*scale+4, d.to.y*scale-4);
    }
    // players
    for(const t of teams){ for(const p of t.players){ p.draw(ctx); } } 
    // vectors
    if(cfg.showVectors){ for(const t of teams){ for(const p of t.players){ ctx.beginPath(); ctx.moveTo(p.x*scale,p.y*scale); ctx.lineTo(p.target.x*scale,p.target.y*scale); ctx.strokeStyle=(t.side===LEFT?'#70d6ffAA':'#ffa3a3AA'); ctx.lineWidth=2; ctx.stroke(); } } } 
    $('clock').textContent = fmtClock(cfg.timeLeft); 
    const dbg=document.getElementById('debugPanel');
    if(dbg){ dbg.textContent=
      `mouse ${mouse.x.toFixed(1)},${mouse.y.toFixed(1)}\n`+
      `ball  ${ball.x.toFixed(2)},${ball.y.toFixed(2)} v ${ball.vx.toFixed(2)},${ball.vy.toFixed(2)}\n`+
      `spd   ${Math.hypot(ball.vx,ball.vy).toFixed(2)}\n`+
      `owner ${ball.owner? (ball.owner.team===LEFT?'L':'R')+' '+ball.owner.role:'none'}\n`+
      `kickΔ ${(gTime-(ball.lastKickAt||0)).toFixed(2)}\n`+
      `scale ${scale.toFixed(2)}`; }
    
    // Update ball owner display
    const ballOwnerEl = document.getElementById('ballOwner');
    if(ballOwnerEl) {
      if(ball.owner) {
        const teamName = ball.owner.team === LEFT ? 'Blue' : 'Red';
        const isHuman = ball.owner.team === humanSide ? ' (YOU)' : ' (AI)';
        ballOwnerEl.textContent = `${teamName} ${ball.owner.role}${isHuman}`;
        ballOwnerEl.style.color = ball.owner.team === humanSide ? '#4cc9f0' : '#ff6b6b';
      } else {
        ballOwnerEl.textContent = 'None';
        ballOwnerEl.style.color = '#9aa3c7';
      }
    }
  }

  function drawField(){ ctx.fillStyle='#1e7f3e'; ctx.fillRect(0,0,W,H); ctx.strokeStyle='#e8ecff'; ctx.lineWidth=2; rect(1*scale,1*scale,(FIELD.w-2)*scale,(FIELD.h-2)*scale); line(FIELD.w/2*scale,1*scale,FIELD.w/2*scale,(FIELD.h-1)*scale); circle(FIELD.w/2*scale,FIELD.h/2*scale,9.15*scale); ctx.beginPath(); ctx.arc(FIELD.w/2*scale,FIELD.h/2*scale,0.6*scale,0,Math.PI*2); ctx.fillStyle='#e8ecff'; ctx.fill(); drawBox(LEFT); drawBox(RIGHT); }
  function rect(x,y,w,h){ ctx.strokeRect(x,y,w,h); } function line(x1,y1,x2,y2){ ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); } function circle(x,y,r){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.stroke(); }
  function drawBox(side){ const bx=BOX, sx=SIX; // penalty & 6-yard boxes
    ctx.strokeRect((side===LEFT?1:FIELD.w-1-bx.w)*scale,(FIELD.h/2-bx.h/2)*scale,bx.w*scale,bx.h*scale);
    ctx.strokeRect((side===LEFT?1:FIELD.w-1-sx.w)*scale,(FIELD.h/2-sx.h/2)*scale,sx.w*scale,sx.h*scale);
    // penalty spot
    ctx.beginPath(); ctx.arc((side===LEFT?(1+11):(FIELD.w-1-11))*scale,FIELD.h/2*scale,0.6*scale,0,Math.PI*2); ctx.fillStyle='#e8ecff'; ctx.fill();
    // goal line (behind keeper)
    ctx.beginPath(); ctx.moveTo((side===LEFT?1:FIELD.w-1)*scale,(FIELD.h/2-GOAL.height/2)*scale);
    ctx.lineTo((side===LEFT?1:FIELD.w-1)*scale,(FIELD.h/2+GOAL.height/2)*scale); ctx.stroke();
  }

  function fmtClock(ms){ const s=Math.ceil(ms/1000); const m=(s/60)|0; const r=(s%60); return String(m).padStart(2,'0')+":"+String(r).padStart(2,'0'); }

  // ---------- Tiny self‑tests (console) ----------
  function assert(name, cond){ (cond? console.log: console.error)(`TEST ${cond?'PASS':'FAIL'}: ${name}`); }
  function approx(a,b,eps=0.05){ return Math.abs(a-b)<=eps; }
  (function runTests(){
    // math
    assert('dist2(0,0,3,4) === 25', dist2(0,0,3,4)===25);
    assert('clamp works', clamp(10,0,5)===5 && clamp(-2,0,5)===0);
    // formation sizes
    assert('formation 4-4-2 has 11 players (LEFT)', buildFormation(LEFT,'4-4-2').length===11);
    assert('formation 4-3-3 has 11 players (RIGHT)', buildFormation(RIGHT,'4-3-3').length===11);
    
    // Wait for canvas to be properly sized before testing coordinates
    setTimeout(() => {
      // client mapping
      const r=canvas.getBoundingClientRect();
      console.log('Canvas rect for test:', r);
      if(r.width > 0 && r.height > 0) {
        const mpInside=clientToField({clientX:r.left+10, clientY:r.top+10});
        const mpOutside=clientToField({clientX:r.left-10, clientY:r.top-10});
        assert('clientToField inside field', mpInside.inside===true);
        assert('clientToField outside field', mpOutside.inside===false);
      } else {
        console.log('Canvas not ready for coordinate test');
      }
    }, 100);
    
    // applyDynamicHomes GK placement
    try{ for(const t of teams){ t.applyDynamicHomes(); } }catch(e){ console.error('applyDynamicHomes threw', e); }
    const gkL=teams[LEFT].players.find(p=>p.role==='GK');
    const gkR=teams[RIGHT].players.find(p=>p.role==='GK');
    assert('GK X LEFT ≈ 1.5', approx(gkL.x,1.5));
    assert('GK X RIGHT ≈ FIELD.w-1.5', approx(gkR.x,FIELD.w-1.5));
    // setFormation homes are finite (regression against disappearing players)
    const tmpTeam=new Team(LEFT,'4-3-3'); tmpTeam.setFormation('3-5-2');
    const bad = tmpTeam.players.some(p=>!Number.isFinite(p.homeBase.x)||!Number.isFinite(p.homeBase.y));
    assert('setFormation creates finite homeBase coords', bad===false);
    // goal detection helper
    const testBall={x:0.3,y:FIELD.h/2, owner:null};
    assert('left goal detected when across line', goalSideIfAny(testBall)===RIGHT);
    const testBallR={x:FIELD.w-0.3,y:FIELD.h/2, owner:null};
    assert('right goal detected when across line', goalSideIfAny(testBallR)===LEFT);
  })();

  // ---------- Init ----------
  resetMatch();
  assert('kickoff gives someone the ball', !!ball.owner);
})();
</script>
</body>
</html>